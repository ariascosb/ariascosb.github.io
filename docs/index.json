[{"content":"Introducción En R todos las variables son objetos. Las asignaciones en R se hacen con \u0026lt;- Los comentarios se hacen con # x\u0026lt;-2 #Esto es un comentario Ctrl+Shift+C #comentarios de mas de una linea Directorio de trabajo actual: getwd() Cambiar directorio: setwd(\u0026ldquo;C:\\otro_directorio\u0026rdquo;) # Ver archivos list.files() # Ver directorios list.dirs() Revisar archivos guardados en memoria ls() Instalar paquetes y librerías install.packages(\u0026#34;readr\u0026#34;) #Instalacion (Solo se hace una vez) library(readr) # Cargue de la libreria (Siempre que se vaya a usar) update.packages() #Actualizar paquetes R #3.6.1 Factores: Agrupación especial de datos. Ejemplo: podemos tener dos tipos de valores en la variable sexo: 1 y 2. A las cuales le podemos asignar unas etiquetas o niveles. Hombres (1) y Mujeres (2). Esto es muy útil para el tratamiento de datos. OJO: los factores siempre quedan guardados como numeros con etiquetas en texto En R, usamos NA para representar datos perdidos, mientras que NULL representa la ausencia de datos. La diferencia entre las dos es que un dato NULL aparece sólo cuando R intenta recuperar un dato y no encuentra nada, mientras que NA es usado para representar explícitamente datos perdidos, omitidos o que por alguna razón son faltantes. NA además puede aparecer como resultado de una operación realizada, pero no tuvo éxito en su ejecución. A diferencia de la mayoría de los lenguajes de programación, los índices en R empiezan en 1, no en 0. Funciones basicas #Limpiar datos rm(list=ls()) #Promedio mean() #Desviacion estandar sd() #Coeficiente de correlacion cor() #Resumen estadistico summary() #Mirar los primeros 10 datos head() #Leer datos CSV paquete base bcancer \u0026lt;- read.csv(\u0026#34;breast-cancer-wis.csv\u0026#34;) bcancer \u0026lt;- read.table(file = \u0026#34;breast-cancer-wis.csv\u0026#34;, header = TRUE, sep = \u0026#34;,\u0026#34;, col.names = nombres) #Exportar datos paquete base write.csv(x = iris, file = \u0026#34;iris.csv\u0026#34;, row.names = FALSE) #OJO NOTA: Se recomiendas usar data table para leer y escribir dado que es mas #rapido que el paquete base #Uso formato .Rds saveRDS(object = mi_lista, file = \u0026#34;mi_lista.rds\u0026#34;) mi_lista_importado \u0026lt;- readRDS(file = \u0026#34;mi_lista.rds\u0026#34;) #Usar un script R desde otro archivo source(\u0026#34;MyScript.R\u0026#34;) Directorios de trabajo\ngetwd() #Directorio actual de trabajo setwd(\u0026#34;C:\\otro_directorio\u0026#34;) #Cambiar el directorio Organizar codigo. Rstudio automaticamente organiza nuestro codigo para que sea mas legible\nContorl +I Control+shift (Mayus) +A Verificar si las librerias estan y instalarlas\n#Verificar librerias list.of.packages \u0026lt;- c(\u0026#34;shiny\u0026#34;,\u0026#34;shinydashboard\u0026#34;,\u0026#34;ggplot2\u0026#34;,\u0026#34;data.table\u0026#34;,\u0026#34;lubridate\u0026#34;) new.packages \u0026lt;- list.of.packages[!(list.of.packages %in% installed.packages()[,\u0026#34;Package\u0026#34;])] if(length(new.packages)) install.packages(new.packages) Acomodar ceros a la derecha y a la izquierda\nSimula la funcion right de excel right = function(text, num_char) { substr(text, nchar(text) - (num_char-1), nchar(text)) } cron[,cantidad.requerida.mix:=round((sum.mix/fc.m.kg)*1000,4),] #Numeros a la derecha cron[,cantidad.requerida.mix:=sprintf(\u0026#34;%f\u0026#34;,cantidad.requerida.mix),] #Numeros a la izquierda cron[,cantidad.requerida.mix:=paste0(\u0026#34;000000000\u0026#34;,cantidad.requerida.mix)] cron[,cantidad.requerida.mix:=right(cantidad.requerida.mix,16)] Tipos de datos Conversión (Coercion). Cuando estas funciones tienen éxito en la coerción, nos devuelven datos del tipo pedido. Si fallan, obtenemos NA como resultado. as.integer()\t#Conversion a Entero as.numeric()\t#Conversion a decimal as.character()\t#Conversion a Cadena de texto as.factor()\t#Conversion a Factor as.logical()\t#Conversion a Lógico as.null()\t#Conversion a NULL #La conversion se da en el siguiente sentido y nunca en el sentido contrario lógico -\u0026gt; entero -\u0026gt; numérico -\u0026gt; cadena de texto (logical -\u0026gt; integer -\u0026gt; numeric -\u0026gt; character) Verficar el tipo de dato str(a) #Me indica que tipo de dato es class(a) #Me indica que tipo de dato es is.integer()\t#Verificar si es Entero is.numeric()\t#Verificar si es decimal is.character()\t#Verificar si es Cadena de texto is.factor()\t#Verificar si es Factor is.logical()\t#Verificar si es Lógico is.null()\t#Verificar si es NULL Operadores Relacionales Operador Comparación \u0026lt; menor que \u0026lt;= menor que \u0026gt; mayor que \u0026gt;= mayor que == igual que != No es igual que Lógicos Operador Comparación x | y x O y es verdadero x \u0026amp; y x Y y es verdadero !x x no es verdadero (negación) Si se comparan dos cadenas de texto con \u0026lt; o \u0026gt; se usa como criterio el orden alfabético\nEstructuras de datos Vectores Un vector es una colección de uno o más datos del mismo tipo.\nvector=c(1,2,3) #La c indica concatenar vector + 2 ===\u0026gt; 3,4,5 vector * 2 ===\u0026gt; 2,4,6 vector[1] #Seleccionar el elemento 1 del vector vector[c(1,3)] #Seleccionar el elemento 1 y 3 del vector vector[1:2] #Seleccionar los elementos del 1 al 2 Matrices y arrays Son vectores multidimensionales. Al igual que un vector, únicamente pueden contener datos de un sólo tipo, pero además de largo, tienen más dimensiones. Cuentan con dos dimensiones, un “largo”\u0026quot; y un “alto”. Las matrices son, por lo tanto, una estructura con forma rectangular, con renglones y columnas.\nmatrix(1:12, nrow = 3, ncol = 4) #Crear matrices con 3 filas y 4 columnas #Se van organizando de arriba hacia abajo por columnas [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 cbind() #para unir vectores, usando cada uno como una columna. rbind() #para unir vectores, usando cada uno como un renglón. dim() # para la dimension de una matriz t(matriz) # Trasponer una matriz Se puede sumar, multiplicar y elevar por un escalar una matriz. Esto afecta todos los valores que existen en ella matriz[filas, columnas] #Seleccion de datos Las matrices siempre serán rectangulares. Cuando intentamos acomodar un número diferente de elementos y celdas, ocurren dos cosas diferentes. Si el número de elementos es mayor al número de celdas, se acomodarán todos los datos que sean posibles y los demás se omitirán. Si, por el contrario, el número de celdas es mayor que el número de elementos, estos se repetirán.\nDataframes Los data frames son estructuras de datos que pueden contener datos de diferentes tipos. los renglones en un data frame representan casos, individuos u observaciones, mientras que las columnas representan atributos, rasgos o variables. Un data frame está compuesto por vectores.\nmi_df \u0026lt;- data.frame( \u0026#34;entero\u0026#34; = 1:4, \u0026#34;factor\u0026#34; = c(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;), \u0026#34;numero\u0026#34; = c(1.2, 3.4, 4.5, 5.6), \u0026#34;cadena\u0026#34; = as.character(c(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;)) ) dim(mi_df) #Conocer dimensiones dataframe names(mi_df) #Conocer el nombre de las columnas dataFrame as.data.frame() #Convertir a data frame data.frame[indice_filas, indice_columnas] #Seleccion de datos data.frame[\u0026#34;name_column\u0026#34;] #Seleccion de datos data.frame$name_column #Seleccion de datos mi_df$c(\u0026#34;nombre\u0026#34;, \u0026#34;edad\u0026#34;) #Seleccionar datos. iris[iris$Sepal.Length \u0026gt; 7.5, ] #Seleccion con validacion #Otra forma de seleccion #Data, condicion, seleccion de columnas subset(x = iris, subset = Sepal.Length \u0026gt; 7.5, select = c(\u0026#34;Sepal.Length\u0026#34;, \u0026#34;Species\u0026#34;)) Listas Las listas, al igual que los vectores, son estructuras de datos unidimensionales, sólo tienen largo, pero a diferencia de los vectores cada uno de sus elementos puede ser de diferente tipo o incluso de diferente clase. Al igual que con un data frame, tenemos la opción de poner nombre a cada elemento de una lista.\nmi_matriz \u0026lt;- matrix(1:4, nrow = 2) mi_df \u0026lt;- data.frame(\u0026#34;num\u0026#34; = 1:3, \u0026#34;let\u0026#34; = c(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)) mi_lista \u0026lt;- list(\u0026#34;un_vector\u0026#34; = mi_vector, \u0026#34;una_matriz\u0026#34; = mi_matriz, \u0026#34;un_df\u0026#34; = mi_df) mi_lista Coerción Función Coerciona a Coersionar exitosamente a as.vector() vector matrices as.matrix() matrices vectores, data frames as.data.frame() data frame vectores, matrices as.list() lista vectores, matrices, data frames Funciones #Definicion nombre \u0026lt;- function(argumento1,argumento2,etc) { operaciones } #Ejemplo area_cuad \u0026lt;- function(lado1, lado2) { lado1 * lado2 } #Forma de llamado 1 area_cuad(lado1 = 4, lado2 = 6) #Forma de llamado 2 area_cuad(4,6) Estructuras de control If-Else if(condición) { operaciones_si_la_condición_es_TRUE } else { operaciones_si_la_condición_es_FALSE } #Ejemplo if(media \u0026gt;= 6) { print(paste0(texto, \u0026#34;aprobado\u0026#34;)) } else { print(paste0(texto, \u0026#34;reprobado\u0026#34;)) } #Otra forma ifelse(vector, valor_si_TRUE, valor_si_FALSE) #Ejemplo ifelse(num %% 2 == 0 \u0026amp; num %% 3, \u0026#34;Divisible\u0026#34;, \u0026#34;No divisible\u0026#34;) For Este ciclo no es el mas recomendado, existe otras alternativas en R mas potenciales para ejecutar estas tareas.\nfor(elemento in objeto) { operacion_con_elemento } #Ejemplo dado \u0026lt;- 1:6 for(cara in dado) { dado ^ 2 } For para añadir filas a una data table\nv\u0026lt;-colores$cod.ext.2 n\u0026lt;-1 list\u0026lt;-as.list(NULL) for (i in v){ a\u0026lt;-conector a$ext.2\u0026lt;-paste0(i) list[[n]]\u0026lt;-a conector1\u0026lt;-rbindlist(list) n\u0026lt;-n+1 } Para imprimir imagenes de un ggplot\ndata_g\u0026lt;-data[maquina==i,] p\u0026lt;-ggplot(data=data_g, aes(x=mes, y=metros, fill=metodo)) + geom_bar(stat=\u0026#34;identity\u0026#34;, position=position_dodge())+ geom_text(aes(label=metros), vjust=1.6, color=\u0026#34;white\u0026#34;, position = position_dodge(0.9), size=2.8)+ scale_fill_brewer(palette=\u0026#34;Paired\u0026#34;)+ theme_minimal()+ labs(title=paste0(i))+theme(plot.title = element_text(hjust = 0.5)) ggsave(paste0(i,\u0026#34;.png\u0026#34;)) print(p) While while(condicion) { operaciones } #Ejemplo while(i \u0026lt; 10) { print(\u0026#34;Presiona ESC para detener\u0026#34;) } Next y Break #Next (Salta parte de un cilo) for(i in 1:4) { if(i == 3) { next } print(i) } #Break (Rompe un ciclo) for(i in 1:10) { if(i == 3) { break } print(i) } Repeat repeat { operaciones un_break_para_detener } #Ejemplo repeat{ valor \u0026lt;- valor + 1 if(valor == 5) { break } } Si no incluimos un break, el bucle se repetirá indefinidamente y sólo lo podremos detener pulsando la tecla ESC, así que hay que tener cuidado al usar esta estructura de control\nData table Librería mas veloz y flexible para el manejo de tablas en R.\nSiempre que tengas datos para analizar en computador, trata de tenerlos en formato largo, es mucho más fácil de trabajar con ellos. Para convertir una tabla ancha en una larga, usa data.table::melt.\nSiempre que tengas que generar datos para interpretación por humanos, considera ponerlos en formato ancho, son más fáciles de entender. Podes lograrlo con data.table::dcast.\n#Actualizar todos los paquetes update.packages(ask = FALSE) #Instalar paquete install.packages(\u0026#34;data.table\u0026#34;) install.packages(\u0026#34;tidyverse\u0026#34;, dependencies = TRUE) #Cargar libreria library(data.table) #Crear data table mi_df \u0026lt;- data.table( \u0026#34;entero\u0026#34; = 1:4, \u0026#34;factor\u0026#34; = c(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;), \u0026#34;numero\u0026#34; = c(1.2, 3.4, 4.5, 5.6), \u0026#34;cadena\u0026#34; = as.character(c(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;)) ) #leer datos data \u0026lt;- fread(\u0026#34;data/item_julio.csv\u0026#34;) #Se recomienda usa r col class para idnicar que tipo de datos son y ahorrar tiempo de carga tipo\u0026lt;-c(\u0026#34;character\u0026#34;,\u0026#34;character\u0026#34;,\u0026#34;character\u0026#34;)#Permite cargar mas rapido y evitar errores conector \u0026lt;- fread(\u0026#34;data/conector_ref.csv\u0026#34;, colClasses = tipo) #Escribir datos fwrite(x =conector, file = \u0026#34;exit/testing.csv\u0026#34;, sep = \u0026#34;,\u0026#34;, dec = \u0026#34;.\u0026#34;) #eliminar duplicados unique(Item) #Estructura data table[i,j,by=k] #i sirve para filtrar irisDT[Species == \u0026#34;setosa\u0026#34;, ] irisDT[Petal.Width \u0026gt; 2, ] irisDT[Petal.Width \u0026lt;= 0.3 \u0026amp; Sepal.Length \u0026gt; 5,] irisDT[c(1, 4),] irisDT[c(\u0026#34;color\u0026#34;,\u0026#34;altura\u0026#34;),] #La j sirve para operar (¿que queremos hacer con los datos?) irisDT[Species == \u0026#34;versicolor\u0026#34;, mean(Sepal.Length)] irisDT[Species == \u0026#34;versicolor\u0026#34;, .(promedio = mean(Sepal.Length), mediana = median(Sepal.Length))] #varias operaciones al mismo tiempo irisDT[Species == \u0026#34;versicolor\u0026#34;, hist(Sepal.Length)] #La k sirve para agrupar irisDT[ , mean(Sepal.Length), by = Species] irisDT[Sepal.Width \u0026gt;= 3, mean(Sepal.Length), by = Species] irisDT[, mean(Sepal.Length), by = .(Species, petaloPequeno = Petal.Width \u0026lt; .3)] #Contar el número de registros. .N #Cambiar nombres a las variables names (DatosTdoPeso) = c(\u0026#34;Tratamiento\u0026#34;, \u0026#34;Variedad\u0026#34;, \u0026#34;Parcela\u0026#34;, \u0026#34;Peso46a60\u0026#34;) #Cambiar NA por otros valores my_data[is.na(my_data)] \u0026lt;- 0 #Cambiar solo un nombre de una columna names (DatosTdoPeso)[3] = \u0026#34;Parcela\u0026#34; #Cambiar el orden de las columnas, se recomienda hacerlo por nombres DatosTdoPeso1 = DatosTdoPeso [ , c(3,2,1,7,6,5,4)] DatosTdoPeso1 = DatosTdoPeso [ , c(\u0026#34;name\u0026#34;,\u0026#34;fecha\u0026#34;,\u0026#34;key\u0026#34;)] #cambiar el orden del eje x en ggplot2 equiposDeslizadores1$month \u0026lt;- factor(equiposDeslizadores1$month,levels = c(0,1,2,3,4,5,6,7,8,9,10,11,12,13),labels = c(\u0026#34;YTD18\u0026#34;, \u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;YTD19\u0026#34;)) #Funciones especiales #Entre irisDT[Sepal.Length %between% c(5.1, 5.2)] #Como irisDT[Species %like% \u0026#34;v.*\u0026#34;,] #Tabla ancha a larga dfLarga_2 \u0026lt;- melt(dfAncha, id.vars = \u0026#34;item\u0026#34;, #id=datos que no vamos a cambiar variable.name = \u0026#34;region\u0026#34;, #var.name= nombre encabezados a poner largos value.name = \u0026#34;valor\u0026#34;, #value= valores de los var.name variable.factor = FALSE) #Tabla larga a ancha dfAncha_2 \u0026lt;- dcast(dfLarga, item ~ region, # x ~ y (filas ~ columnas) value.var = \u0026#34;valor\u0026#34;) #Contar el numero de elementos por filas. Se uso en lista de materiales col.base\u0026lt;-col.base[ , index := 1:.N , by = c(\u0026#34;cod.ext.2.col\u0026#34;) ] #Convierte , en . epoxica$produccion.und\u0026lt;-gsub(\u0026#34;,\u0026#34;, \u0026#34;.\u0026#34;, epoxica$produccion.und) #Nueva forma buscarv nominalesEnsamble \u0026lt;- fread(\u0026#34;files/nominales/nominales_ensamble.csv\u0026#34;) setkeyv(ensamble, c(\u0026#34;maquina\u0026#34;, \u0026#34;proceso\u0026#34;)) setkeyv(nominalesEnsamble, c(\u0026#34;maquina\u0026#34;, \u0026#34;proceso\u0026#34;)) ensamble[nominalesEnsamble, nominal := nominal] Excel library(\u0026#34;writexl\u0026#34;) library(\u0026#34;readxl\u0026#34;) data\u0026lt;- read_excel(\u0026#34;data/data.xlsx\u0026#34;) data\u0026lt;-as.data.table(data) write_xlsx(comision, \u0026#34;exits/comisiones.xlsx\u0026#34;) ","permalink":"http://localhost:1313/2023/10/mis-apuntes-de-r/","summary":"Introducción En R todos las variables son objetos. Las asignaciones en R se hacen con \u0026lt;- Los comentarios se hacen con # x\u0026lt;-2 #Esto es un comentario Ctrl+Shift+C #comentarios de mas de una linea Directorio de trabajo actual: getwd() Cambiar directorio: setwd(\u0026ldquo;C:\\otro_directorio\u0026rdquo;) # Ver archivos list.files() # Ver directorios list.dirs() Revisar archivos guardados en memoria ls() Instalar paquetes y librerías install.packages(\u0026#34;readr\u0026#34;) #Instalacion (Solo se hace una vez) library(readr) # Cargue de la libreria (Siempre que se vaya a usar) update.","title":"Mis apuntes de R"},{"content":"Trabajando con WSL encontré la nueva windows terminal y se me hizo muy comodo trabajar en ella. Sin embargo, el principal problema que tenia era que cada vez que iniciaba el directorio predeterminado era uno tipo /mnt/c/Users/. Esto era molesto dado que constantemente tenia que trasladarme a un directorio dentro de mi home. Para solucionar este problema tenemos que seguir los siguientes pasos.\nEntramos al archivo de configuración settings.json presionando las siguientes teclas ctrl + shift + , Dentro de este archivo configuramos la sección startingDirectory. Después del código //wsl$/Ubuntu-20.04 se añade la ubicación que deseamos. En mi caso quiero iniciar dentro de la carpeta /home/ariascosb/Projects por tanto debe quedar asi: { \u0026#34;guid\u0026#34;: \u0026#34;{07b52e3e-de2c-5db4-bd2d-ba144ed6c273}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Ubuntu-20.04\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Wsl\u0026#34;, \u0026#34;startingDirectory\u0026#34; : \u0026#34;//wsl$/Ubuntu-20.04/home/ariascosb/Projects\u0026#34; }, NOTA: Solo se debe agregar la linea startingDirectory, por favor no modifiques nada adicional. Si estas usando otra version de linux cambias el Ubuntu-20.04 por la tuya\n","permalink":"http://localhost:1313/2023/05/como-configurar-el-directorio-de-inicio-para-wsl-en-la-windows-terminal/","summary":"Trabajando con WSL encontré la nueva windows terminal y se me hizo muy comodo trabajar en ella. Sin embargo, el principal problema que tenia era que cada vez que iniciaba el directorio predeterminado era uno tipo /mnt/c/Users/. Esto era molesto dado que constantemente tenia que trasladarme a un directorio dentro de mi home. Para solucionar este problema tenemos que seguir los siguientes pasos.\nEntramos al archivo de configuración settings.json presionando las siguientes teclas ctrl + shift + , Dentro de este archivo configuramos la sección startingDirectory.","title":"Como configurar el directorio de inicio para WSL en la windows terminal"},{"content":"WSL nos permite tener una distribución linux en windows 10. La nueva version WSL2 mejora el rendimiento notablemente comparandola con la version anterior y la he adoptado como entorno de desarrollo en mi dia a dia. Una labor rutinaria y frecuente que se realiza es mantener actualizado el sistema, por eso te quiero mostrar el código bash que utilizo para realizar esta tarea.\nCreamos un script .sh, en mi caso lo llamo ubuntu.sh nano ubuntu.sh Ingresamos el siguiente código dentro del script. Este permite actualizar los repositorios, luego los paquetes y finalmente limpiar la cache. Al final siempre se imprime un mensaje de éxito o alerta para avisarnos el estado final del proceso. #!/bin/bash update() { apt-get update; apt-get upgrade; if [ $? -ne 0 ]; then echo \u0026#34;UBUNTU NO SE ACTUALIZO CORRECTAMENTE \u0026#34; else apt-get autoclean; apt-get clean; apt-get autoremove echo \u0026#34;UBUNTU SE ACTUALIZO CORRECTAMENTE \u0026#34; fi } update Añadimos permisos de ejecución. chmod +x ubuntu.sh Creamos un alias. Esto nos permitirá ejecutar el script con un nombre personalizado. Iniciamos abriendo el archivo .bashrc nano ~/.bashrc Bajamos hasta el final del archivo .bashrc y copiamos la siguiente linea de código. Debes tener cuidado con colocar la ubicación correcta de tu archivo .sh alias ubuntu=\u0026#34;sudo /home/ariascosb/ubuntu.sh\u0026#34; En mi caso el nombre personalizado que les estoy dando es ubuntu, pero tu lo puedes cambiar al editar la palabra que esta después de alias y antes del signo igual (=).\nEsta todo listo, ahora para ejecutar el script solo bastara con escribir en la terminal el alias (en mi caso: ubuntu), digitamos nuestra contraseña y automáticamente se actualizara nuestra distribución en WSL. ubuntu ","permalink":"http://localhost:1313/2023/05/mi-script-bash-para-actualizar-ubuntu/","summary":"WSL nos permite tener una distribución linux en windows 10. La nueva version WSL2 mejora el rendimiento notablemente comparandola con la version anterior y la he adoptado como entorno de desarrollo en mi dia a dia. Una labor rutinaria y frecuente que se realiza es mantener actualizado el sistema, por eso te quiero mostrar el código bash que utilizo para realizar esta tarea.\nCreamos un script .sh, en mi caso lo llamo ubuntu.","title":"Mi script bash para actualizar Ubuntu"}]